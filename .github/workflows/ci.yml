name: ci

on:
  pull_request:
  push:
    branches:
      - main

permissions:
  contents: read
  pull-requests: write

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        if: ${{ !env.ACT }}
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod

      - name: Setup Go (act)
        if: ${{ env.ACT }}
        run: |
          if ! command -v go >/dev/null 2>&1; then
            apt-get update
            apt-get install -y golang-go
          fi
          go version

      - name: Install tooling
        run: |
          go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.9.0
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          if [ -z "${ACT:-}" ]; then
            echo "$(go env GOPATH)/bin" >> "$GITHUB_PATH"
          fi

      - name: Run CI target
        run: |
          if [ -n "${ACT:-}" ]; then
            PATH="$(go env GOPATH)/bin:$PATH" make ci
          else
            make ci
          fi

      - name: Verify demo assets are up to date
        run: make demos-check

      - name: Run lopper self-analysis (PR)
        id: lopper
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          mkdir -p .artifacts
          bin/lopper analyse --top 10 --repo . --language all --format json > .artifacts/lopper-pr.json

      - name: Run lopper self-analysis (base branch)
        id: lopper_base
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          mkdir -p .artifacts
          git fetch --no-tags --depth=1 origin "${{ github.event.pull_request.base.ref }}"
          git worktree add --detach .artifacts/base "origin/${{ github.event.pull_request.base.ref }}"
          bin/lopper analyse --top 10 --repo .artifacts/base --language all --format json > .artifacts/lopper-base.json
          git worktree remove --force .artifacts/base

      - name: Comment lopper report on PR
        if: ${{ github.event_name == 'pull_request' && !env.ACT }}
        uses: actions/github-script@v8
        env:
          LOPPER_OUTCOME: ${{ steps.lopper.outcome }}
          LOPPER_BASE_OUTCOME: ${{ steps.lopper_base.outcome }}
        with:
          script: |
            const fs = require('node:fs');

            const marker = '<!-- lopper-pr-report -->';
            const reportPath = '.artifacts/lopper-pr.json';
            const baseReportPath = '.artifacts/lopper-base.json';

            const escapeTable = (value) => String(value ?? 'n/a').replace(/\|/g, '\\|').replace(/`/g, "'");
            const pct = (value) => (typeof value === 'number' && Number.isFinite(value) ? `${value.toFixed(1)}%` : 'n/a');
            const signedPct = (value) =>
              typeof value === 'number' && Number.isFinite(value)
                ? `${value >= 0 ? '+' : ''}${value.toFixed(1)}%`
                : 'n/a';
            const intFmt = (value) =>
              typeof value === 'number' && Number.isFinite(value)
                ? Math.round(value).toLocaleString('en-US')
                : 'n/a';
            const signedInt = (value) =>
              typeof value === 'number' && Number.isFinite(value)
                ? `${value >= 0 ? '+' : ''}${Math.round(value).toLocaleString('en-US')}`
                : 'n/a';
            const depKey = (dep) => `${dep.language || 'unknown'}::${dep.name || 'unknown'}`;
            const toMap = (deps) => {
              const map = new Map();
              for (const dep of deps || []) map.set(depKey(dep), dep);
              return map;
            };

            let body = null;
            let noChange = false;
            if (
              process.env.LOPPER_OUTCOME !== 'success' ||
              process.env.LOPPER_BASE_OUTCOME !== 'success' ||
              !fs.existsSync(reportPath) ||
              !fs.existsSync(baseReportPath)
            ) {
              body = [
                marker,
                '## Lopper (Delta)',
                '',
                '❌ Lopper delta analysis failed in CI.',
                '',
                'Re-run the workflow, or run local head/base analyses and compare JSON outputs.',
              ].join('\n');
            } else {
              const head = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
              const base = JSON.parse(fs.readFileSync(baseReportPath, 'utf8'));
              const headSummary = head.summary || {};
              const baseSummary = base.summary || {};
              const headDeps = Array.isArray(head.dependencies) ? head.dependencies : [];
              const baseDeps = Array.isArray(base.dependencies) ? base.dependencies : [];

              const headMap = toMap(headDeps);
              const baseMap = toMap(baseDeps);
              const keys = new Set([...headMap.keys(), ...baseMap.keys()]);

              const deltas = [];
              for (const key of keys) {
                const h = headMap.get(key);
                const b = baseMap.get(key);

                if (h && !b) {
                  deltas.push({
                    type: 'added',
                    name: h.name,
                    language: h.language,
                    deltaUnused: h.estimatedUnusedBytes ?? 0,
                    deltaUsedPercent: null,
                    deltaUsedExports: h.usedExportsCount ?? 0,
                    deltaTotalExports: h.totalExportsCount ?? 0,
                  });
                  continue;
                }

                if (!h && b) {
                  deltas.push({
                    type: 'removed',
                    name: b.name,
                    language: b.language,
                    deltaUnused: -(b.estimatedUnusedBytes ?? 0),
                    deltaUsedPercent: null,
                    deltaUsedExports: -(b.usedExportsCount ?? 0),
                    deltaTotalExports: -(b.totalExportsCount ?? 0),
                  });
                  continue;
                }

                const deltaUnused = (h?.estimatedUnusedBytes ?? 0) - (b?.estimatedUnusedBytes ?? 0);
                const deltaUsedPercent = (h?.usedPercent ?? 0) - (b?.usedPercent ?? 0);
                const deltaUsedExports = (h?.usedExportsCount ?? 0) - (b?.usedExportsCount ?? 0);
                const deltaTotalExports = (h?.totalExportsCount ?? 0) - (b?.totalExportsCount ?? 0);
                const changed =
                  deltaUnused !== 0 ||
                  deltaUsedExports !== 0 ||
                  deltaTotalExports !== 0;
                if (changed) {
                  deltas.push({
                    type: 'changed',
                    name: h?.name,
                    language: h?.language,
                    deltaUnused,
                    deltaUsedPercent,
                    deltaUsedExports,
                    deltaTotalExports,
                  });
                }
              }

              deltas.sort((a, b) => Math.abs(b.deltaUnused) - Math.abs(a.deltaUnused));
              const topDeltas = deltas.slice(0, 15);
              const deltaRows = topDeltas.length
                ? topDeltas
                    .map(
                      (row, idx) =>
                        `| ${idx + 1} | ${row.type} | \`${escapeTable(row.name)}\` | ${escapeTable(row.language)} | ${signedPct(row.deltaUsedPercent)} | ${signedInt(row.deltaUsedExports)} | ${signedInt(row.deltaTotalExports)} | ${signedInt(row.deltaUnused)} |`,
                    )
                    .join('\n')
                : '| - | _No dependency deltas detected_ | - | - | - | - | - | - |';

              const depCountDelta = (headSummary.dependencyCount ?? 0) - (baseSummary.dependencyCount ?? 0);
              const usedPctDelta = (headSummary.usedPercent ?? 0) - (baseSummary.usedPercent ?? 0);
              const unusedBytesHead = headDeps.reduce((sum, dep) => sum + (dep.estimatedUnusedBytes ?? 0), 0);
              const unusedBytesBase = baseDeps.reduce((sum, dep) => sum + (dep.estimatedUnusedBytes ?? 0), 0);
              const unusedBytesDelta = unusedBytesHead - unusedBytesBase;
              const hasSummaryDelta =
                depCountDelta !== 0 || Math.abs(usedPctDelta) > 1e-9 || unusedBytesDelta !== 0;
              const hasDependencyDelta = deltas.length > 0;

              if (!hasSummaryDelta && !hasDependencyDelta) {
                noChange = true;
              } else {
                body = [
                  marker,
                  '## Lopper (Delta)',
                  '',
                  '**Compared:** PR head vs base branch',
                  '',
                  '| Metric delta | Value |',
                  '| --- | --- |',
                  `| Dependency count | ${signedInt(depCountDelta)} |`,
                  `| Used percent | ${signedPct(usedPctDelta)} |`,
                  `| Estimated unused bytes | ${signedInt(unusedBytesDelta)} |`,
                  '',
                  '_Used percent is weighted: sum(usedExportsCount) / sum(totalExportsCount)._',
                  '',
                  '### Dependency deltas',
                  '',
                  '| # | Change | Dependency | Language | Used % delta | Used exports delta | Total exports delta | Unused bytes delta |',
                  '| --- | --- | --- | --- | --- | --- | --- | --- |',
                  deltaRows,
                ].join('\n');
              }
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (noChange) {
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                });
              }
              return;
            }

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Run coverage gate
        id: cov
        continue-on-error: true
        env:
          COVERAGE_MIN: 95
        run: |
          set +e
          if [ -n "${ACT:-}" ]; then
            PATH="$(go env GOPATH)/bin:$PATH" make cov COVERAGE_MIN="${COVERAGE_MIN}"
          else
            make cov COVERAGE_MIN="${COVERAGE_MIN}"
          fi
          status=$?
          if [ -f .artifacts/coverage-total.txt ]; then
            total="$(cat .artifacts/coverage-total.txt)"
          else
            total=""
          fi
          echo "total=$total" >> "$GITHUB_OUTPUT"
          exit $status

      - name: Comment on coverage failure
        if: ${{ github.event_name == 'pull_request' && steps.cov.outcome == 'failure' && !env.ACT }}
        uses: actions/github-script@v8
        env:
          COVERAGE_MIN: 95
          COVERAGE_TOTAL: ${{ steps.cov.outputs.total }}
        with:
          script: |
            const marker = '<!-- lopper-coverage-failure -->';
            const total = process.env.COVERAGE_TOTAL || 'unavailable';
            const body = `${marker}
            ❌ Coverage gate failed.

            Required: >= ${process.env.COVERAGE_MIN}%
            Actual: ${total === 'unavailable' ? total : `${total}%`}

            Run \`make cov\` locally for details.`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Fail workflow on coverage gate
        if: ${{ steps.cov.outcome == 'failure' }}
        run: exit 1

      - name: Upload binary artifact
        if: ${{ always() && !env.ACT }}
        uses: actions/upload-artifact@v6
        with:
          name: lopper-bin
          path: bin/lopper
          if-no-files-found: ignore

      - name: Mock artifact upload (act)
        if: ${{ always() && env.ACT }}
        run: |
          test -f bin/lopper
          ls -lh bin/lopper

  homebrew-tap-verify:
    runs-on: ubuntu-latest
    steps:
      - name: Detect tap repository
        id: tap
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if gh repo view ben-ranford/homebrew-tap >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Homebrew
        if: ${{ steps.tap.outputs.exists == 'true' }}
        uses: Homebrew/actions/setup-homebrew@master

      - name: Checkout tap formula
        if: ${{ steps.tap.outputs.exists == 'true' }}
        uses: actions/checkout@v6
        with:
          repository: ben-ranford/homebrew-tap
          path: homebrew-tap

      - name: Run Homebrew audit and test
        if: ${{ steps.tap.outputs.exists == 'true' }}
        run: |
          set -euo pipefail
          brew audit --strict --online --formula homebrew-tap/Formula/lopper.rb
          brew install --build-from-source homebrew-tap/Formula/lopper.rb
          brew test lopper

      - name: Skip when tap is not created yet
        if: ${{ steps.tap.outputs.exists != 'true' }}
        run: echo "homebrew-tap repository not found; skipping Homebrew tap verification."
