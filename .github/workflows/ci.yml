name: ci

on:
  pull_request:
  push:
    branches:
      - main

jobs:
  verify:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Go
        if: ${{ !env.ACT }}
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod

      - name: Setup Go (act)
        if: ${{ env.ACT }}
        run: |
          if ! command -v go >/dev/null 2>&1; then
            apt-get update
            apt-get install -y golang-go
          fi
          go version

      - name: Install tooling
        run: |
          go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.9.0
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          if [ -z "${ACT:-}" ]; then
            echo "$(go env GOPATH)/bin" >> "$GITHUB_PATH"
          fi

      - name: Run CI target
        run: |
          if [ -n "${ACT:-}" ]; then
            PATH="$(go env GOPATH)/bin:$PATH" make ci
          else
            make ci
          fi

      - name: Verify demo assets are up to date
        run: make demos-check

      - name: Run lopper self-analysis (PR)
        id: lopper
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          mkdir -p .artifacts
          bin/lopper analyse --top 10 --repo . --language all --format json > .artifacts/lopper-pr.json

      - name: Run lopper self-analysis (base branch)
        id: lopper_base
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          mkdir -p .artifacts
          git fetch --no-tags --depth=1 origin "${{ github.event.pull_request.base.ref }}"
          git worktree add --detach .artifacts/base "origin/${{ github.event.pull_request.base.ref }}"
          bin/lopper analyse --top 10 --repo .artifacts/base --language all --format json > .artifacts/lopper-base.json
          git worktree remove --force .artifacts/base

      - name: Comment lopper report on PR
        if: ${{ github.event_name == 'pull_request' && !env.ACT }}
        uses: actions/github-script@v8
        env:
          LOPPER_OUTCOME: ${{ steps.lopper.outcome }}
          LOPPER_BASE_OUTCOME: ${{ steps.lopper_base.outcome }}
        with:
          script: |
            const fs = require('node:fs');

            const marker = '<!-- lopper-pr-report -->';
            const reportPath = '.artifacts/lopper-pr.json';
            const baseReportPath = '.artifacts/lopper-base.json';

            const escapeTable = (value) => String(value ?? 'n/a').replace(/\|/g, '\\|').replace(/`/g, "'");
            const pct = (value) => (typeof value === 'number' && Number.isFinite(value) ? `${value.toFixed(1)}%` : 'n/a');
            const signedPct = (value) =>
              typeof value === 'number' && Number.isFinite(value)
                ? `${value >= 0 ? '+' : ''}${value.toFixed(1)}%`
                : 'n/a';
            const intFmt = (value) =>
              typeof value === 'number' && Number.isFinite(value)
                ? Math.round(value).toLocaleString('en-US')
                : 'n/a';
            const signedInt = (value) =>
              typeof value === 'number' && Number.isFinite(value)
                ? `${value >= 0 ? '+' : ''}${Math.round(value).toLocaleString('en-US')}`
                : 'n/a';
            const depKey = (dep) => `${dep.language || 'unknown'}::${dep.name || 'unknown'}`;
            const toMap = (deps) => {
              const map = new Map();
              for (const dep of deps || []) map.set(depKey(dep), dep);
              return map;
            };

            let body = null;
            let noChange = false;
            if (
              process.env.LOPPER_OUTCOME !== 'success' ||
              process.env.LOPPER_BASE_OUTCOME !== 'success' ||
              !fs.existsSync(reportPath) ||
              !fs.existsSync(baseReportPath)
            ) {
              body = [
                marker,
                '## Lopper (Delta)',
                '',
                '❌ Lopper delta analysis failed in CI.',
                '',
                'Re-run the workflow, or run local head/base analyses and compare JSON outputs.',
              ].join('\n');
            } else {
              const head = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
              const base = JSON.parse(fs.readFileSync(baseReportPath, 'utf8'));
              const headSummary = head.summary || {};
              const baseSummary = base.summary || {};
              const headDeps = Array.isArray(head.dependencies) ? head.dependencies : [];
              const baseDeps = Array.isArray(base.dependencies) ? base.dependencies : [];

              const headMap = toMap(headDeps);
              const baseMap = toMap(baseDeps);
              const keys = new Set([...headMap.keys(), ...baseMap.keys()]);

              const deltas = [];
              for (const key of keys) {
                const h = headMap.get(key);
                const b = baseMap.get(key);

                if (h && !b) {
                  deltas.push({
                    type: 'added',
                    name: h.name,
                    language: h.language,
                    deltaUnused: h.estimatedUnusedBytes ?? 0,
                    deltaUsedPercent: null,
                    deltaUsedExports: h.usedExportsCount ?? 0,
                    deltaTotalExports: h.totalExportsCount ?? 0,
                  });
                  continue;
                }

                if (!h && b) {
                  deltas.push({
                    type: 'removed',
                    name: b.name,
                    language: b.language,
                    deltaUnused: -(b.estimatedUnusedBytes ?? 0),
                    deltaUsedPercent: null,
                    deltaUsedExports: -(b.usedExportsCount ?? 0),
                    deltaTotalExports: -(b.totalExportsCount ?? 0),
                  });
                  continue;
                }

                const deltaUnused = (h?.estimatedUnusedBytes ?? 0) - (b?.estimatedUnusedBytes ?? 0);
                const deltaUsedPercent = (h?.usedPercent ?? 0) - (b?.usedPercent ?? 0);
                const deltaUsedExports = (h?.usedExportsCount ?? 0) - (b?.usedExportsCount ?? 0);
                const deltaTotalExports = (h?.totalExportsCount ?? 0) - (b?.totalExportsCount ?? 0);
                const changed =
                  deltaUnused !== 0 ||
                  deltaUsedExports !== 0 ||
                  deltaTotalExports !== 0;
                if (changed) {
                  deltas.push({
                    type: 'changed',
                    name: h?.name,
                    language: h?.language,
                    deltaUnused,
                    deltaUsedPercent,
                    deltaUsedExports,
                    deltaTotalExports,
                  });
                }
              }

              deltas.sort((a, b) => Math.abs(b.deltaUnused) - Math.abs(a.deltaUnused));
              const topDeltas = deltas.slice(0, 15);
              const deltaRows = topDeltas.length
                ? topDeltas
                    .map(
                      (row, idx) =>
                        `| ${idx + 1} | ${row.type} | \`${escapeTable(row.name)}\` | ${escapeTable(row.language)} | ${signedPct(row.deltaUsedPercent)} | ${signedInt(row.deltaUsedExports)} | ${signedInt(row.deltaTotalExports)} | ${signedInt(row.deltaUnused)} |`,
                    )
                    .join('\n')
                : '| - | _No dependency deltas detected_ | - | - | - | - | - | - |';

              const depCountDelta = (headSummary.dependencyCount ?? 0) - (baseSummary.dependencyCount ?? 0);
              const usedPctDelta = (headSummary.usedPercent ?? 0) - (baseSummary.usedPercent ?? 0);
              const unusedBytesHead = headDeps.reduce((sum, dep) => sum + (dep.estimatedUnusedBytes ?? 0), 0);
              const unusedBytesBase = baseDeps.reduce((sum, dep) => sum + (dep.estimatedUnusedBytes ?? 0), 0);
              const unusedBytesDelta = unusedBytesHead - unusedBytesBase;
              const hasSummaryDelta =
                depCountDelta !== 0 || Math.abs(usedPctDelta) > 1e-9 || unusedBytesDelta !== 0;
              const hasDependencyDelta = deltas.length > 0;

              if (!hasSummaryDelta && !hasDependencyDelta) {
                noChange = true;
              } else {
                body = [
                  marker,
                  '## Lopper (Delta)',
                  '',
                  '**Compared:** PR head vs base branch',
                  '',
                  '| Metric delta | Value |',
                  '| --- | --- |',
                  `| Dependency count | ${signedInt(depCountDelta)} |`,
                  `| Used percent | ${signedPct(usedPctDelta)} |`,
                  `| Estimated unused bytes | ${signedInt(unusedBytesDelta)} |`,
                  '',
                  '_Used percent is weighted: sum(usedExportsCount) / sum(totalExportsCount)._',
                  '',
                  '### Dependency deltas',
                  '',
                  '| # | Change | Dependency | Language | Used % delta | Used exports delta | Total exports delta | Unused bytes delta |',
                  '| --- | --- | --- | --- | --- | --- | --- | --- |',
                  deltaRows,
                ].join('\n');
              }
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (noChange) {
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                });
              }
              return;
            }

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Post SonarQube review comments (PR)
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ben-ranford_lopper
          SONAR_HOST_URL: https://sonarcloud.io
        if: ${{ github.event_name == 'pull_request' && !env.ACT && env.SONAR_TOKEN != '' }}
        continue-on-error: true
        uses: actions/github-script@v8
        with:
          script: |
            const marker = '<!-- lopper-sonar-review -->';
            const token = process.env.SONAR_TOKEN || '';
            const projectKey = process.env.SONAR_PROJECT_KEY || '';
            const host = (process.env.SONAR_HOST_URL || 'https://sonarcloud.io').replace(/\/+$/, '');
            const prNumber = context.payload.pull_request?.number;

            if (!prNumber) {
              core.info('No pull request context available, skipping Sonar comment.');
              return;
            }

            if (!token || !projectKey) {
              core.info('SONAR_TOKEN or project key is missing, skipping Sonar comment.');
              return;
            }

            const params = new URLSearchParams({
              componentKeys: projectKey,
              pullRequest: String(prNumber),
              resolved: 'false',
              p: '1',
              ps: '20',
            });
            const auth = `Basic ${Buffer.from(`${token}:`).toString('base64')}`;
            const jsonHeaders = {
              Authorization: auth,
              Accept: 'application/json',
            };
            const fetchJSON = async (path, searchParams) => {
              const endpoint = `${host}${path}?${searchParams.toString()}`;
              const response = await fetch(endpoint, { headers: jsonHeaders });
              if (!response.ok) {
                throw new Error(`Sonar API request failed (${response.status}): ${await response.text()}`);
              }
              return response.json();
            };

            const payload = await fetchJSON('/api/issues/search', params);
            const issues = Array.isArray(payload.issues) ? payload.issues : [];
            const total = Number.isFinite(payload.total) ? payload.total : issues.length;
            const extractPath = (component) => {
              const raw = String(component || '');
              return raw.includes(':') ? raw.slice(raw.indexOf(':') + 1) : raw;
            };
            const isMockOrFixtureIssue = (issue) => {
              const path = extractPath(issue.component);
              return /(^|\/)(mock|mocks|testdata)(\/|$)/.test(path) || /(^|\/)[^/]+_mock\.go$/.test(path);
            };
            const actionableIssues = issues.filter((issue) => !isMockOrFixtureIssue(issue));
            const excludedCount = issues.length - actionableIssues.length;
            const list = actionableIssues.slice(0, 10);

            let duplicationSummary = '_Duplication metrics unavailable for this PR._';
            try {
              const measureParams = new URLSearchParams({
                component: projectKey,
                pullRequest: String(prNumber),
                metricKeys: 'duplicated_lines,duplicated_lines_density,new_duplicated_lines,new_duplicated_lines_density',
              });
              const measurePayload = await fetchJSON('/api/measures/component', measureParams);
              const measures = Array.isArray(measurePayload?.component?.measures) ? measurePayload.component.measures : [];
              const getMeasure = (metric) => measures.find((m) => m?.metric === metric)?.value;
              const fmtPercent = (value) => {
                const n = Number(value);
                return Number.isFinite(n) ? `${n.toFixed(2)}%` : 'n/a';
              };
              const fmtInt = (value) => {
                const n = Number(value);
                return Number.isFinite(n) ? `${Math.round(n)}` : 'n/a';
              };
              duplicationSummary = [
                `- Overall duplicated lines: **${fmtInt(getMeasure('duplicated_lines'))}**`,
                `- Overall duplication density: **${fmtPercent(getMeasure('duplicated_lines_density'))}**`,
                `- New duplicated lines: **${fmtInt(getMeasure('new_duplicated_lines'))}**`,
                `- New duplication density: **${fmtPercent(getMeasure('new_duplicated_lines_density'))}**`,
              ].join('\n');
            } catch (error) {
              core.warning(`Failed to fetch Sonar duplication measures: ${error.message}`);
            }

            const issueRows =
              list.length > 0
                ? list
                    .map((issue, idx) => {
                      const severity = String(issue.severity || 'UNKNOWN');
                      const rule = String(issue.rule || 'n/a');
                      const component = String(issue.component || '').split(':').slice(1).join(':') || 'n/a';
                      const line = issue.line ? `:${issue.line}` : '';
                      const message = String(issue.message || '').replace(/\|/g, '\\|').replace(/\n+/g, ' ');
                      return `| ${idx + 1} | ${severity} | \`${rule}\` | \`${component}${line}\` | ${message} |`;
                    })
                    .join('\n')
                : '| - | - | - | - | No open Sonar issues for this PR. |';

            const body = [
              marker,
              '## SonarQube (PR)',
              '',
              `Open issues: **${total}**`,
              `Actionable issues shown (excluding mock/fixture files): **${actionableIssues.length}**`,
              excludedCount > 0 ? `Excluded mock/fixture issues: **${excludedCount}**` : '',
              '',
              '### Duplication',
              duplicationSummary,
              '',
              '### Issues',
              '',
              '| # | Severity | Rule | Location | Message |',
              '| --- | --- | --- | --- | --- |',
              issueRows,
              '',
              `Source: [SonarCloud PR view](${host}/project/issues?id=${encodeURIComponent(projectKey)}&pullRequest=${prNumber}&resolved=false)`,
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Run coverage gate
        id: cov
        continue-on-error: true
        env:
          COVERAGE_MIN: 95
        run: |
          set +e
          if [ -n "${ACT:-}" ]; then
            PATH="$(go env GOPATH)/bin:$PATH" make cov COVERAGE_MIN="${COVERAGE_MIN}"
          else
            make cov COVERAGE_MIN="${COVERAGE_MIN}"
          fi
          status=$?
          if [ -f .artifacts/coverage-total.txt ]; then
            total="$(cat .artifacts/coverage-total.txt)"
          else
            total=""
          fi
          echo "total=$total" >> "$GITHUB_OUTPUT"
          exit $status

      - name: Comment on coverage failure
        if: ${{ github.event_name == 'pull_request' && steps.cov.outcome == 'failure' && !env.ACT }}
        uses: actions/github-script@v8
        env:
          COVERAGE_MIN: 95
          COVERAGE_TOTAL: ${{ steps.cov.outputs.total }}
        with:
          script: |
            const marker = '<!-- lopper-coverage-failure -->';
            const total = process.env.COVERAGE_TOTAL || 'unavailable';
            const body = `${marker}
            ❌ Coverage gate failed.

            Required: >= ${process.env.COVERAGE_MIN}%
            Actual: ${total === 'unavailable' ? total : `${total}%`}

            Run \`make cov\` locally for details.`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Fail workflow on coverage gate
        if: ${{ steps.cov.outcome == 'failure' }}
        run: exit 1

      - name: Upload binary artifact
        if: ${{ always() && !env.ACT }}
        uses: actions/upload-artifact@v6
        with:
          name: lopper-bin
          path: bin/lopper
          if-no-files-found: ignore

      - name: Mock artifact upload (act)
        if: ${{ always() && env.ACT }}
        run: |
          test -f bin/lopper
          ls -lh bin/lopper

  homebrew-tap-verify:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Detect tap repository
        id: tap
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if gh repo view ben-ranford/homebrew-tap >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Homebrew
        if: ${{ steps.tap.outputs.exists == 'true' }}
        uses: Homebrew/actions/setup-homebrew@04a6d8cfe9d251e2afb78c5bdc6274ec9642aea2

      - name: Checkout tap formula
        if: ${{ steps.tap.outputs.exists == 'true' }}
        uses: actions/checkout@v6
        with:
          repository: ben-ranford/homebrew-tap
          path: homebrew-tap

      - name: Run Homebrew audit and test
        if: ${{ steps.tap.outputs.exists == 'true' }}
        run: |
          set -euo pipefail
          brew untap ben-ranford/tap >/dev/null 2>&1 || true
          brew tap --custom-remote ben-ranford/tap "file://${PWD}/homebrew-tap"
          brew audit --strict --online ben-ranford/tap/lopper
          brew install --build-from-source ben-ranford/tap/lopper
          brew test ben-ranford/tap/lopper

      - name: Skip when tap is not created yet
        if: ${{ steps.tap.outputs.exists != 'true' }}
        run: echo "homebrew-tap repository not found; skipping Homebrew tap verification."
