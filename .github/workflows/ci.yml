name: ci

on:
  pull_request:
  push:
    branches:
      - main

jobs:
  verify:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Go
        if: ${{ !env.ACT }}
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod

      - name: Setup Go (act)
        if: ${{ env.ACT }}
        run: |
          if ! command -v go >/dev/null 2>&1; then
            apt-get update
            apt-get install -y golang-go
          fi
          go version

      - name: Install tooling
        run: |
          go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.9.0
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          if [ -z "${ACT:-}" ]; then
            echo "$(go env GOPATH)/bin" >> "$GITHUB_PATH"
          fi

      - name: Run CI target
        run: |
          if [ -n "${ACT:-}" ]; then
            PATH="$(go env GOPATH)/bin:$PATH" make ci
          else
            make ci
          fi

      - name: Verify demo assets are up to date
        run: make demos-check

      - name: Run lopper self-analysis (base branch)
        id: lopper_base
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          mkdir -p .artifacts
          git fetch --no-tags --depth=1 origin "${{ github.event.pull_request.base.ref }}"
          git worktree add --detach .artifacts/base "origin/${{ github.event.pull_request.base.ref }}"
          bin/lopper analyse --top 10 --repo .artifacts/base --language all --format json > .artifacts/lopper-base.json
          git worktree remove --force .artifacts/base

      - name: Run lopper delta summary (PR)
        id: lopper_delta
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          mkdir -p .artifacts
          bin/lopper analyse --top 10 --repo . --language all --baseline .artifacts/lopper-base.json --format pr-comment > .artifacts/lopper-pr-comment.md

      - name: Comment lopper report on PR
        if: ${{ github.event_name == 'pull_request' && !env.ACT }}
        uses: actions/github-script@v8
        env:
          LOPPER_BASE_OUTCOME: ${{ steps.lopper_base.outcome }}
          LOPPER_DELTA_OUTCOME: ${{ steps.lopper_delta.outcome }}
        with:
          script: |
            const fs = require('node:fs');

            const marker = '<!-- lopper-pr-report -->';
            const deltaCommentPath = '.artifacts/lopper-pr-comment.md';

            const failureBody = [
              marker,
              '## Lopper (Delta)',
              '',
              '❌ Lopper delta analysis failed in CI.',
              '',
              'Re-run the workflow, or run local head/base analyses and compare outputs.',
            ].join('\n');

            const body =
              process.env.LOPPER_BASE_OUTCOME !== 'success' ||
              process.env.LOPPER_DELTA_OUTCOME !== 'success' ||
              !fs.existsSync(deltaCommentPath)
                ? failureBody
                : `${marker}\n${fs.readFileSync(deltaCommentPath, 'utf8').trim()}`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            });

            const existing = comments.filter(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (existing.length > 0) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing[0].id,
                body,
              });
              for (const duplicate of existing.slice(1)) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: duplicate.id,
                });
              }
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Post SonarQube review comments (PR)
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ben-ranford_lopper
          SONAR_HOST_URL: https://sonarcloud.io
        if: ${{ github.event_name == 'pull_request' && !env.ACT && env.SONAR_TOKEN != '' }}
        continue-on-error: true
        uses: actions/github-script@v8
        with:
          script: |
            const marker = '<!-- lopper-sonar-review -->';
            const token = process.env.SONAR_TOKEN || '';
            const projectKey = process.env.SONAR_PROJECT_KEY || '';
            const host = (process.env.SONAR_HOST_URL || 'https://sonarcloud.io').replace(/\/+$/, '');
            const prNumber = context.payload.pull_request?.number;

            if (!prNumber) {
              core.info('No pull request context available, skipping Sonar comment.');
              return;
            }

            if (!token || !projectKey) {
              core.info('SONAR_TOKEN or project key is missing, skipping Sonar comment.');
              return;
            }

            const params = new URLSearchParams({
              componentKeys: projectKey,
              pullRequest: String(prNumber),
              resolved: 'false',
              p: '1',
              ps: '20',
            });
            const auth = `Basic ${Buffer.from(`${token}:`).toString('base64')}`;
            const jsonHeaders = {
              Authorization: auth,
              Accept: 'application/json',
            };
            const fetchJSON = async (path, searchParams) => {
              const endpoint = `${host}${path}?${searchParams.toString()}`;
              const response = await fetch(endpoint, { headers: jsonHeaders });
              if (!response.ok) {
                throw new Error(`Sonar API request failed (${response.status}): ${await response.text()}`);
              }
              return response.json();
            };

            const payload = await fetchJSON('/api/issues/search', params);
            const issues = Array.isArray(payload.issues) ? payload.issues : [];
            const total = Number.isFinite(payload.total) ? payload.total : issues.length;
            const extractPath = (component) => {
              const raw = String(component || '');
              return raw.includes(':') ? raw.slice(raw.indexOf(':') + 1) : raw;
            };
            const isMockOrFixtureIssue = (issue) => {
              const path = extractPath(issue.component);
              return /(^|\/)(mock|mocks|testdata)(\/|$)/.test(path) || /(^|\/)[^/]+_mock\.go$/.test(path);
            };
            const actionableIssues = issues.filter((issue) => !isMockOrFixtureIssue(issue));
            const excludedCount = issues.length - actionableIssues.length;
            const list = actionableIssues;

            let duplicationSummary = '_Duplication metrics unavailable for this PR._';
            try {
              const measureParams = new URLSearchParams({
                component: projectKey,
                pullRequest: String(prNumber),
                metricKeys: 'duplicated_lines,duplicated_lines_density,new_duplicated_lines,new_duplicated_lines_density',
              });
              const measurePayload = await fetchJSON('/api/measures/component', measureParams);
              const measures = Array.isArray(measurePayload?.component?.measures) ? measurePayload.component.measures : [];
              const getMeasure = (metric) => measures.find((m) => m?.metric === metric)?.value;
              const fmtPercent = (value) => {
                const n = Number(value);
                return Number.isFinite(n) ? `${n.toFixed(2)}%` : 'n/a';
              };
              const fmtInt = (value) => {
                const n = Number(value);
                return Number.isFinite(n) ? `${Math.round(n)}` : 'n/a';
              };
              duplicationSummary = [
                `- Overall duplicated lines: **${fmtInt(getMeasure('duplicated_lines'))}**`,
                `- Overall duplication density: **${fmtPercent(getMeasure('duplicated_lines_density'))}**`,
                `- New duplicated lines: **${fmtInt(getMeasure('new_duplicated_lines'))}**`,
                `- New duplication density: **${fmtPercent(getMeasure('new_duplicated_lines_density'))}**`,
              ].join('\n');
            } catch (error) {
              core.warning(`Failed to fetch Sonar duplication measures: ${error.message}`);
            }

            const issueRows =
              list.length > 0
                ? list
                    .map((issue, idx) => {
                      const severity = String(issue.severity || 'UNKNOWN');
                      const rule = String(issue.rule || 'n/a');
                      const component = String(issue.component || '').split(':').slice(1).join(':') || 'n/a';
                      const line = issue.line ? `:${issue.line}` : '';
                      const message = String(issue.message || '').replace(/\|/g, '\\|').replace(/\n+/g, ' ');
                      return `| ${idx + 1} | ${severity} | \`${rule}\` | \`${component}${line}\` | ${message} |`;
                    })
                    .join('\n')
                : '| - | - | - | - | No open Sonar issues for this PR. |';

            const body = [
              marker,
              '## SonarQube (PR)',
              '',
              `Open issues: **${total}**`,
              `Actionable issues shown (excluding mock/fixture files): **${actionableIssues.length}**`,
              excludedCount > 0 ? `Excluded mock/fixture issues: **${excludedCount}**` : '',
              '',
              '### Duplication',
              duplicationSummary,
              '',
              '### Issues',
              '',
              '<details>',
              `<summary>Open Sonar issues (${actionableIssues.length})</summary>`,
              '',
              '| # | Severity | Rule | Location | Message |',
              '| --- | --- | --- | --- | --- |',
              issueRows,
              '',
              '</details>',
              '',
              `Source: [SonarCloud PR view](${host}/project/issues?id=${encodeURIComponent(projectKey)}&pullRequest=${prNumber}&resolved=false)`,
            ].join('\n');

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            });
            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Run coverage gate
        id: cov
        continue-on-error: true
        env:
          COVERAGE_MIN: 95
        run: |
          set +e
          if [ -n "${ACT:-}" ]; then
            PATH="$(go env GOPATH)/bin:$PATH" make cov COVERAGE_MIN="${COVERAGE_MIN}"
          else
            make cov COVERAGE_MIN="${COVERAGE_MIN}"
          fi
          status=$?
          if [ -f .artifacts/coverage-total.txt ]; then
            total="$(cat .artifacts/coverage-total.txt)"
          else
            total=""
          fi
          echo "total=$total" >> "$GITHUB_OUTPUT"
          exit $status

      - name: Comment on coverage failure
        if: ${{ github.event_name == 'pull_request' && steps.cov.outcome == 'failure' && !env.ACT }}
        uses: actions/github-script@v8
        env:
          COVERAGE_MIN: 95
          COVERAGE_TOTAL: ${{ steps.cov.outputs.total }}
        with:
          script: |
            const marker = '<!-- lopper-coverage-failure -->';
            const total = process.env.COVERAGE_TOTAL || 'unavailable';
            const body = `${marker}
            ❌ Coverage gate failed.

            Required: >= ${process.env.COVERAGE_MIN}%
            Actual: ${total === 'unavailable' ? total : `${total}%`}

            Run \`make cov\` locally for details.`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            });

            const existing = comments.find(
              (comment) =>
                comment.user?.type === 'Bot' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker),
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Fail workflow on coverage gate
        if: ${{ steps.cov.outcome == 'failure' }}
        run: exit 1

      - name: Upload binary artifact
        if: ${{ always() && !env.ACT }}
        uses: actions/upload-artifact@v6
        with:
          name: lopper-bin
          path: bin/lopper
          if-no-files-found: ignore

      - name: Mock artifact upload (act)
        if: ${{ always() && env.ACT }}
        run: |
          test -f bin/lopper
          ls -lh bin/lopper

  homebrew-tap-verify:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Detect tap repository
        id: tap
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if gh repo view ben-ranford/homebrew-tap >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Homebrew
        if: ${{ steps.tap.outputs.exists == 'true' }}
        uses: Homebrew/actions/setup-homebrew@ac2ec1ccabf33716b2fe5f4d467e250296951780

      - name: Checkout tap formula
        if: ${{ steps.tap.outputs.exists == 'true' }}
        uses: actions/checkout@v6
        with:
          repository: ben-ranford/homebrew-tap
          path: homebrew-tap

      - name: Run Homebrew audit and test
        if: ${{ steps.tap.outputs.exists == 'true' }}
        run: |
          set -euo pipefail
          brew untap ben-ranford/tap >/dev/null 2>&1 || true
          brew tap --custom-remote ben-ranford/tap "file://${PWD}/homebrew-tap"
          brew audit --strict --online ben-ranford/tap/lopper
          brew install --build-from-source ben-ranford/tap/lopper
          brew test ben-ranford/tap/lopper

      - name: Skip when tap is not created yet
        if: ${{ steps.tap.outputs.exists != 'true' }}
        run: echo "homebrew-tap repository not found; skipping Homebrew tap verification."
